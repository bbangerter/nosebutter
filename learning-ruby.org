* Learning Ruby
http://www.sitepoint.com/functional-programming-techniques-with-ruby-part-ii/
** =inject=
*** Example - How to sum from 1 to 10 with =inject=

#+BEGIN_QUOTE
In functional programming, fold – also known variously as reduce, accumulate, aggregate, compress, or inject – refers to a family of higher-order functions that analyze a recursive data structure and recombine through use of a given combining operation the results of recursively processing its constituent parts, building up a return value. Typically, a fold is presented with a combining function, a top node of a data structure, and possibly some default values to be used under certain conditions. The fold then proceeds to combine elements of the data structure's hierarchy, using the function in a systematic way.[fn:1] Wikipedia - Fold (higher-order function)
#+END_QUOTE

#+name: example-sum-1-to-10-with-inject-ruby
#+begin_src ruby
(1..10).inject(&:+)
#+end_src

#+RESULTS: example-sum-1-to-10-with-inject-ruby
: 55

**** Reading
http://stackoverflow.com/questions/710501/need-a-simple-explanation-of-the-inject-method
http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
http://stackoverflow.com/questions/9429819/what-is-the-functionality-of-operator-in-ruby
http://stackoverflow.com/questions/1961030/ruby-ampersand-colon-shortcut
http://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby
http://en.wikipedia.org/wiki/Higher-order_function

#+BEGIN_COMMENT
There is another huge advantage of lazy evaluation. Look at this code:

1
(1..100).select { |x| x % 3 == 0 }.select { |x| x % 4 == 0 }
This code attempts to find all numbers between 1 and 100 that are divisible by both 3 and 4, but in the process iterates over the set of numbers twice! Lazy evaluation collapses all of the enumerator actions into a single iteration:

1
(1..100).lazy.select { |x| x % 3 == 0 }.select { |x| x % 4 == 0 }.to_a
This could dramatically speed up code where multiple filters are being applied to a collection. This collapsing of the enumerable chain works for any of the many methods defined on the Enumerable class, including but not limited to, #select, #map and #take.


#+END_COMMENT

** Fun with Arrays

*** Use =include?= to filter rows in array then order columns with =map=

Note: =include?= does *exact match* not regular expression 

#+name: example-filter-then-order-array-ruby
#+header: :var data='(("a" "b" "c") ("b" "c" "d") ("c" "d" "e"))
#+header: :var filter="c"
#+header: :var columns='(1 0)
#+header: :results replace 
#+begin_src ruby
  # Bug: Adding ":colnames yes" breaks this code
  data.select{|d| Array.new(d) if d.include?(filter)}.map{|d1| Array.new(columns.length){|i| d1.fetch(columns[i])}} 
#+end_src

#+RESULTS: filter-then-order-array-ruby
| b | a |
| c | b |
| d | c |
** Currying
*** Explain Example Code using Literate Programming
**** Original Example Code

[[http://blog.daniellobato.me/2013/06/why-is-curry-not-popular-among-rubyists%EF%BB%BF%EF%BB%BF/]]

#+begin_src ruby
is_weekday = lambda {|day_of_week, time| time.wday == day_of_week}.curry

sunday    = is_weekday[0]
monday    = is_weekday[1]
tuesday   = is_weekday[2]
wednesday = is_weekday[3]
thursday  = is_weekday[4]
friday    = is_weekday[5]
saturday  = is_weekday[6]

case Time.now
when sunday 
  puts "Day of rest"
when monday, tuesday, wednesday, thursday, friday
  puts "Work"
when saturday
  puts "chores"
end
#+end_src

* Footnotes

[fn:1] http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29

